<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1251">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice 4.0.0  (Win32)">
	<META NAME="CREATED" CONTENT="20130826;18542682">
	<META NAME="CHANGED" CONTENT="20130827;19324737">
	<STYLE TYPE="text/css">
	<!--
		@page { size: 21cm 29.7cm; margin: 2cm }
		H2 { page-break-after: avoid }
		H2.western { font-family: "Arial", sans-serif; font-size: 14pt; font-style: italic; font-weight: bold }
		H2.cjk { font-family: "Arial Unicode MS"; font-size: 14pt; font-style: italic; font-weight: bold }
		H2.ctl { font-family: "Mangal"; font-size: 14pt; font-style: italic; font-weight: bold }
		P.sdfootnote { font-size: 10pt }
		H3 { page-break-after: avoid }
		H3.western { font-family: "Arial", sans-serif; font-size: 14pt; font-weight: bold }
		H3.cjk { font-family: "Arial Unicode MS"; font-size: 14pt; font-weight: bold }
		H3.ctl { font-family: "Mangal"; font-size: 14pt; font-weight: bold }
		H4 { page-break-after: avoid }
		H4.western { font-family: "Arial", sans-serif; font-size: 11pt; font-style: italic; font-weight: bold }
		H4.cjk { font-family: "Arial Unicode MS"; font-size: 11pt; font-style: italic; font-weight: bold }
		H4.ctl { font-family: "Mangal"; font-size: 11pt; font-style: italic; font-weight: bold }
		H5 { page-break-after: avoid }
		H5.western { font-family: "Arial", sans-serif; font-size: 11pt; font-weight: bold }
		H5.cjk { font-family: "Arial Unicode MS"; font-size: 11pt; font-weight: bold }
		H5.ctl { font-family: "Mangal"; font-size: 11pt; font-weight: bold }
		TH P { font-weight: bold; widows: 4 }
		CODE { font-family: "Courier New", monospace }
		STRONG { font-weight: bold }
		A:link { color: #000080; so-language: zxx; text-decoration: underline }
		A:visited { color: #800000; so-language: zxx; text-decoration: underline }
		A.sdfootnoteanc { font-size: 57% }
	-->
	</STYLE>
</HEAD>
<BODY LANG="ru-RU" LINK="#000080" VLINK="#800000" DIR="LTR">
<H2 CLASS="western">Input <SPAN LANG="en-US">g</SPAN>rammar</H2>
<P LANG="en-US">Input grammar consists of:</P>
<UL>
	<LI><P LANG="en-US">Rules (at least one)</P>
	<LI><P LANG="en-US">Code insertions (optional)</P>
	<LI><P LANG="en-US">Comments (optional)</P>
</UL>
<H3 LANG="en-US" CLASS="western">Rules</H3>
<P LANG="en-US">Rules have the following form:</P>
<P><CODE><SPAN LANG="en-US">nonterminal &lt;- expression ;</SPAN></CODE></P>
<P><SPAN LANG="en-US">(You may use &ldquo;</SPAN><CODE><SPAN LANG="en-US">=</SPAN></CODE>&rdquo;
<SPAN LANG="en-US">or &ldquo;</SPAN><CODE>&larr;</CODE>&rdquo;
<SPAN LANG="en-US">instead of &ldquo;</SPAN><CODE><SPAN LANG="en-US">&lt;-</SPAN></CODE>&rdquo;<SPAN LANG="en-US">.)</SPAN></P>
<P><CODE><SPAN LANG="en-US">expression</SPAN></CODE> <SPAN LANG="en-US">describes
how to parse input. Valid </SPAN><CODE><SPAN LANG="en-US">expression</SPAN></CODE><SPAN LANG="en-US">s
are listed in &ldquo;Parsing expressions&rdquo; section below.</SPAN></P>
<H4 LANG="en-US" CLASS="western">Semantic values</H4>
<P><SPAN LANG="en-US">Each rule has a semantic value. You may set it
in runtime by setting Ruby variable </SPAN><CODE><SPAN LANG="en-US">val</SPAN></CODE>
<SPAN LANG="en-US">in the right-hand expression of the rule. When the
rule is executed, its semantic value becomes semantic value of the
nonterminal which caused the rule execution. In the following example
nonterminal </SPAN><CODE><SPAN LANG="en-US">ntrm</SPAN></CODE> <SPAN LANG="en-US">in
the first rule receives semantic value </SPAN><CODE><SPAN LANG="en-US">&quot;b&quot;</SPAN></CODE><SPAN LANG="en-US">:</SPAN></P>
<P><CODE><SPAN LANG="en-US">text &larr; &quot;a&quot; ntrm ;</SPAN></CODE></P>
<P><CODE><SPAN LANG="en-US">ntrm &larr; &quot;b&quot;:val ;</SPAN></CODE></P>
<P LANG="en-US">You may capture the semantic values into Ruby
variables (as shown in the example; see corresponding &ldquo;Capture&rdquo;
expressions in &ldquo;Parsing expressions&rdquo; section), process
them inside code insertions (the semantic values are valid Ruby
objects) and even return them as resultant value from the parser.</P>
<P LANG="en-US">You also may define the type of the semantic value of
the rule:</P>
<P><CODE><SPAN LANG="en-US">nonterminal: Type &larr; expression ;</SPAN></CODE></P>
<P LANG="en-US">(Currently semantic value types are not processed
anyhow and serve the informational purposes only.)</P>
<H4 LANG="en-US" CLASS="western">Parsing expressions</H4>
<TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=5 CELLSPACING=0>
	<COL WIDTH=85*>
	<COL WIDTH=43*>
	<COL WIDTH=43*>
	<COL WIDTH=85*>
	<THEAD>
		<TR VALIGN=TOP>
			<TH WIDTH=33%>
				<P LANG="en-US">Expression</P>
			</TH>
			<TH COLSPAN=2 WIDTH=34%>
				<P LANG="en-US"><FONT FACE="Times New Roman, serif">Meaning</FONT></P>
			</TH>
			<TH WIDTH=33%>
				<P LANG="en-US">Semantic value</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&quot;string&quot;</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 COLSPAN=2 WIDTH=34%>
				<P><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">Read
				</SPAN></FONT><CODE><SPAN LANG="en-US">string</SPAN></CODE> <FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">from
				input.</SPAN></FONT></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">string<A CLASS="sdfootnoteanc" NAME="sdfootnote1anc" HREF="#sdfootnote1sym"><SUP>1</SUP></A></SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">'string'</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">U+HHHH</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P LANG="en-US">Read UTF-8 encoded character with Unicode code
				U+HHHH from input.</P>
			</TD>
			<TD WIDTH=33%>
				<P><SPAN LANG="en-US">A </SPAN><CODE><SPAN LANG="en-US">String</SPAN></CODE>
				<SPAN LANG="en-US">containing the read character.</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P LANG="en-US"><CODE>char</CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P LANG="en-US">Read UTF-8 encoded character from input.</P>
			</TD>
			<TD WIDTH=33%>
				<P><SPAN LANG="en-US">A </SPAN><CODE><SPAN LANG="en-US">String</SPAN></CODE>
				<SPAN LANG="en-US">containing the read character.</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">x...y</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=4 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Read a character from input which is in the
				range between </SPAN><CODE><SPAN LANG="en-US">x</SPAN></CODE> <SPAN LANG="en-US">and
				</SPAN><CODE><SPAN LANG="en-US">y</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
				<P><CODE><SPAN LANG="en-US">x</SPAN></CODE> <SPAN LANG="en-US">and
				</SPAN><CODE><SPAN LANG="en-US">y</SPAN></CODE> <SPAN LANG="en-US">may
				be of the form of </SPAN><CODE><SPAN LANG="en-US">&quot;c&quot;</SPAN></CODE><SPAN LANG="en-US">,
				</SPAN><CODE><SPAN LANG="en-US">'c'</SPAN></CODE> <SPAN LANG="en-US">or
				</SPAN><CODE><SPAN LANG="en-US">U+HHHH</SPAN></CODE><SPAN LANG="en-US">.
				Examples:</SPAN></P>
				<UL>
					<LI><P><CODE><SPAN LANG="en-US">'a'...'z'</SPAN></CODE></P>
					<LI><P><CODE><SPAN LANG="en-US">U+0000...U+0020</SPAN></CODE></P>
					<LI><P><CODE><SPAN LANG="en-US">'a'...U+2025</SPAN></CODE></P>
				</UL>
			</TD>
			<TD ROWSPAN=4 WIDTH=33%>
				<P><SPAN LANG="en-US">A </SPAN><CODE><SPAN LANG="en-US">String</SPAN></CODE>
				<SPAN LANG="en-US">containing the read character.</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">x..y</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">x&hellip;</SPAN></CODE><CODE><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">y</SPAN></FONT></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">x..y<A CLASS="sdfootnoteanc" NAME="sdfootnote2anc" HREF="#sdfootnote2sym"><SUP>2</SUP></A></SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">{ code }</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=3 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Execute </SPAN><CODE><SPAN LANG="en-US">code</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
				<P><STRONG><SPAN LANG="en-US">Attention!</SPAN></STRONG> <SPAN LANG="en-US">Do
				not declare variables or use </SPAN><CODE><SPAN LANG="en-US">Symbol</SPAN></CODE><SPAN LANG="en-US">s
				with names starting with &ldquo;</SPAN><CODE><SPAN LANG="en-US">yy_</SPAN></CODE>&rdquo;
				<SPAN LANG="en-US">in </SPAN><CODE><SPAN LANG="en-US">code</SPAN></CODE><SPAN LANG="en-US">!
				They are reserved by the parser generator!</SPAN></P>
			</TD>
			<TD ROWSPAN=3 WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">{... code ...}</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">{... code }...</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">$</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P LANG="en-US">Fail everywhere except the end of the input.</P>
			</TD>
			<TD WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">^</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P LANG="en-US">Fail everywhere except the beginning of the
				input.</P>
			</TD>
			<TD WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">@</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P LANG="en-US">Get current position in input.</P>
			</TD>
			<TD WIDTH=33%>
				<P LANG="en-US">Current position in input.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P LANG="en-US"><CODE>@=var</CODE></P>
			</TD>
			<TD ROWSPAN=2 COLSPAN=2 WIDTH=34%>
				<P LANG="en-US"><BR>
				</P>
			</TD>
			<TD ROWSPAN=2 WIDTH=33%>
				<P LANG="en-US" ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P LANG="en-US"><CODE>at var</CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">nonterminal</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Use rule having </SPAN><CODE><SPAN LANG="en-US">nonterminal</SPAN></CODE>
				<SPAN LANG="en-US">as its left part to parse input.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P LANG="en-US">The rule's semantic value.</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<P LANG="en-US" ALIGN=CENTER STYLE="widows: 4"><I><B>Combinations
				(ordered by priority)<A CLASS="sdfootnoteanc" NAME="sdfootnote3anc" HREF="#sdfootnote3sym"><SUP>3</SUP></A></B></I></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr1 / expr2</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Choice (ordered). Parse input with </SPAN><CODE><SPAN LANG="en-US">expr1</SPAN></CODE><SPAN LANG="en-US">.
				If it fails then parse it with </SPAN><CODE><SPAN LANG="en-US">expr2</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE>/ </CODE><CODE><SPAN LANG="en-US">expr1 / expr2</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr1 expr2</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Sequence. Parse input with </SPAN><CODE><SPAN LANG="en-US">expr1</SPAN></CODE>
				<SPAN LANG="en-US">then with </SPAN><CODE><SPAN LANG="en-US">expr2</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr ]</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">The same as </SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr</SPAN></CODE><SPAN LANG="en-US">'s
				semantic value.</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">(expr)</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr:var<A CLASS="sdfootnoteanc" NAME="sdfootnote4anc" HREF="#sdfootnote4sym"><SUP>4</SUP></A></SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Capture (semantic value). Parse input with
				</SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE> <SPAN LANG="en-US">and
				capture its semantic value into Ruby variable </SPAN><CODE><SPAN LANG="en-US">var</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr</SPAN></CODE><SPAN LANG="en-US">'s
				semantic value.</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr :+ var</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Append (semantic value). Parse input with
				</SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE> <SPAN LANG="en-US">and
				append its semantic value to Ruby variable </SPAN><CODE><SPAN LANG="en-US">var</SPAN></CODE><SPAN LANG="en-US">.
				Append is performed with &ldquo;</SPAN><CODE><SPAN LANG="en-US">&lt;&lt;</SPAN></CODE>&rdquo;
				<SPAN LANG="en-US">operator (e. g., &ldquo;</SPAN><CODE><SPAN LANG="en-US">var&nbsp;&lt;&lt;&nbsp;yy_expr_value</SPAN></CODE>&rdquo;<SPAN LANG="en-US">).</SPAN></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr :&gt;&gt; var</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&amp;expr</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Predicate. Remember current position in
				input, parse input with </SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE>
				<SPAN LANG="en-US">and go back to the remembered position.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE>!</CODE><CODE><SPAN LANG="en-US">expr</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Predicate (negative). The same as </SPAN><CODE><SPAN LANG="en-US">&amp;expr</SPAN></CODE>
				<SPAN LANG="en-US">but it fails if </SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE>
				<SPAN LANG="en-US">parses input successfully.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&amp;{ code }</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=3 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Predicate (code). Fail if </SPAN><CODE><SPAN LANG="en-US">code</SPAN></CODE>
				<SPAN LANG="en-US">evaluates to false or nil.</SPAN></P>
			</TD>
			<TD ROWSPAN=3 WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&amp;{... code ...}</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&amp;{... code }...</SPAN></CODE></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=33% VALIGN=TOP>
				<P><CODE><SPAN LANG="en-US">expr*</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=3 WIDTH=17%>
				<P><SPAN LANG="en-US">Repetition. Repeat parsing input with </SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE>&hellip;</P>
			</TD>
			<TD WIDTH=17% VALIGN=TOP>
				<P>&hellip;<SPAN LANG="en-US">zero or more times.</SPAN></P>
			</TD>
			<TD ROWSPAN=3 WIDTH=33% VALIGN=TOP>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=33% VALIGN=TOP>
				<P><CODE><SPAN LANG="en-US">expr+</SPAN></CODE></P>
			</TD>
			<TD WIDTH=17% VALIGN=TOP>
				<P>&hellip;<SPAN LANG="en-US">one or more times.</SPAN></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=33% VALIGN=TOP>
				<P><CODE><SPAN LANG="en-US">expr?</SPAN></CODE></P>
			</TD>
			<TD WIDTH=17% VALIGN=TOP>
				<P>&hellip;<SPAN LANG="en-US">zero or one time.</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">expr*?</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Repetition (lazy). Repeat parsing input
				with </SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE> <SPAN LANG="en-US">until
				next expression in sequence with it succeeds. See examples in
				section &ldquo;Lazy repetition: examples&rdquo;.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&lt; expr &gt;:var</SPAN></CODE></P>
			</TD>
			<TD COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Capture (text). Capture text consumed by
				</SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE> <SPAN LANG="en-US">into
				Ruby variable </SPAN><CODE><SPAN LANG="en-US">var</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
			</TD>
			<TD WIDTH=33%>
				<P><SPAN LANG="en-US">Captured text (as </SPAN><CODE><SPAN LANG="en-US">String</SPAN></CODE><SPAN LANG="en-US">).</SPAN></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&lt; expr &gt; :+ var</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 COLSPAN=2 WIDTH=34%>
				<P><SPAN LANG="en-US">Append (text). Append text consumed by </SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE>
				<SPAN LANG="en-US">to Ruby variable </SPAN><CODE><SPAN LANG="en-US">var</SPAN></CODE><SPAN LANG="en-US">.</SPAN></P>
				<P><SPAN LANG="en-US">Appending is performed with Ruby operator
				&ldquo;</SPAN><CODE><SPAN LANG="en-US">&lt;&lt;</SPAN></CODE>&rdquo;<SPAN LANG="en-US">.</SPAN></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=33%>
				<P ALIGN=CENTER STYLE="widows: 4">&mdash;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=33%>
				<P><CODE><SPAN LANG="en-US">&lt; expr &gt; :&gt;&gt; var</SPAN></CODE></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P><BR><BR>
</P>
<H5 CLASS="western">Lazy repetition: examples</H5>
<TABLE WIDTH=100% BORDER=2 BORDERCOLOR="#000000" CELLPADDING=5 CELLSPACING=0>
	<COL WIDTH=128*>
	<COL WIDTH=128*>
	<THEAD>
		<TR VALIGN=TOP>
			<TH WIDTH=50%>
				<P LANG="en-US">Expression</P>
			</TH>
			<TH WIDTH=50%>
				<P LANG="en-US">Equivalent to&hellip;</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">a*? b</SPAN></CODE></P>
			</TD>
			<TD WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">(!b a) b</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">(a*?) b</SPAN></CODE></P>
			</TD>
			<TD WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">(!b a) b</SPAN></CODE></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">a*? b c</SPAN></CODE></P>
			</TD>
			<TD WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">(!(b c) a) b c</SPAN></CODE></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=50% VALIGN=TOP>
				<P><CODE><SPAN LANG="en-US">(a*? b c) d</SPAN></CODE></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=50%>
				<P><CODE><SPAN LANG="en-US">( (!(b c) a) b c ) d</SPAN></CODE></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=50% VALIGN=TOP>
				<P><CODE><SPAN LANG="en-US">a*? b c ] d</SPAN></CODE></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P><BR><BR>
</P>
<H3 LANG="en-US" CLASS="western">Code insertions</H3>
<P LANG="en-US">Every code insertion has one of the following forms:</P>
<UL>
	<LI><P><CODE><SPAN LANG="en-US">{ code }</SPAN></CODE></P>
	<LI><P><CODE><SPAN LANG="en-US">{... code ...}</SPAN></CODE></P>
	<LI><P><CODE><SPAN LANG="en-US">{... code }...</SPAN></CODE></P>
</UL>
<P LANG="en-US">They are written into the output parser &ldquo;as
is&rdquo;. A code insertion before all rules and other code
insertions is put into the beginning of the output file. A code
insertion after all rules and other code insertions is put into the
end of the output file. Other code insertions are put somewhere in
the middle of the output file.</P>
<P><STRONG><SPAN LANG="en-US">Attention!</SPAN></STRONG> <SPAN LANG="en-US">Do
not declare methods, classes, modules, variables etc. with names
starting with &ldquo;</SPAN><CODE><SPAN LANG="en-US">yy_</SPAN></CODE>&rdquo;
<SPAN LANG="en-US">or &ldquo;</SPAN><CODE><SPAN LANG="en-US">YY_</SPAN></CODE>&rdquo;
<SPAN LANG="en-US">in the code insertions! They are reserved by the
parser generator!</SPAN></P>
<H3 LANG="en-US" CLASS="western">Comments</H3>
<P><SPAN LANG="en-US">Comments can be written anywhere in the input
grammar except identifiers and atomic expressions. A comment starts
with &ldquo;</SPAN><CODE><SPAN LANG="en-US">#</SPAN></CODE>&rdquo; <SPAN LANG="en-US">or
&ldquo;</SPAN><CODE><SPAN LANG="en-US">--</SPAN></CODE>&rdquo; <SPAN LANG="en-US">and
continues until the end of the line.</SPAN></P>
<P LANG="en-US">Following are examples of comments:</P>
<P><CODE><SPAN LANG="en-US"># Simple comment</SPAN></CODE></P>
<P><CODE><SPAN LANG="en-US">-- Another comment</SPAN></CODE></P>
<P><CODE><SPAN LANG="en-US">---- Section delimiter, a comment too
----</SPAN></CODE></P>
<H2 LANG="en-US" CLASS="western">Output parser</H2>
<P LANG="en-US">The output of the parser generator is a Ruby script
containing the following:</P>
<OL>
	<LI><P LANG="en-US">Content of the code insertion before all rules
	and other code insertions (if it is present);</P>
	<LI><P><CODE><SPAN LANG="en-US">yy_parse(io)</SPAN></CODE> <SPAN LANG="en-US">function
	definition. It receives an </SPAN><CODE><SPAN LANG="en-US">IO</SPAN></CODE>
	<SPAN LANG="en-US">and parses it according to the first rule in the
	input grammar. Its return value is semantic value of that rule. If
	it can not parse the input (due to syntax error in it) then it
	raises </SPAN><CODE><SPAN LANG="en-US">YY_SyntaxError</SPAN></CODE>
	<SPAN LANG="en-US">(see below).</SPAN></P>
	<LI><P><CODE><SPAN LANG="en-US">YY_SyntaxError</SPAN></CODE> <SPAN LANG="en-US">class
	definition. It is a subclass of </SPAN><CODE><SPAN LANG="en-US">Exception</SPAN></CODE>
	<SPAN LANG="en-US">and has the following methods:</SPAN></P>
	<OL>
		<LI><P><CODE><SPAN LANG="en-US">pos</SPAN></CODE><SPAN LANG="en-US">.
		It returns an offset in input (in bytes) the </SPAN><CODE><SPAN LANG="en-US">YY_SyntaxError</SPAN></CODE>
		<SPAN LANG="en-US">has occurred at.</SPAN></P>
	</OL>
	<LI><P LANG="en-US">Auxiliary functions and classes definitions.
	Their names always start with &ldquo;yy_&rdquo; (for functions) and
	&ldquo;YY_&rdquo; (for classes and modules).</P>
	<LI><P LANG="en-US">Content of the code insertion after all rules
	and other code insertions (if it is present).</P>
</OL>
<H3 LANG="en-US" CLASS="western">Multiple parser entry points</H3>
<P LANG="en-US">yy_parse(io) always starts parsing with the first
rule from the input grammar. But what if you need to start parsing
with another rule?</P>
<P LANG="en-US">No problem, just define the required rule as follows:</P>
<P><CODE><SPAN LANG="en-US">rule_name() &larr; expression ;</SPAN></CODE></P>
<P><SPAN LANG="en-US">and the parser generator will generate a
function which is named after the rule's left-hand side nonterminal
(</SPAN><CODE><SPAN LANG="en-US">rule_name</SPAN></CODE> <SPAN LANG="en-US">in
this example) and which behaves the same as </SPAN><CODE><SPAN LANG="en-US">yy_parse(io)</SPAN></CODE>
<SPAN LANG="en-US">but starts parsing input with the defined rule!</SPAN></P>
<P LANG="en-US">Other valid forms for such a rule are:</P>
<UL>
	<LI><P><CODE><SPAN LANG="en-US">rule_name(...) &larr; expression
	;</SPAN></CODE><SPAN LANG="en-US"><BR>(here &ldquo;...&rdquo; is
	three dots, not some arbitrary expression)</SPAN></P>
	<LI><P><CODE><SPAN LANG="en-US">rule_name(arg) &larr; expression
	;</SPAN></CODE><SPAN LANG="en-US"><BR>(here arg is a valid Ruby
	variable name)</SPAN></P>
</UL>
<P LANG="en-US">Of course you may define the rule's semantic value
type as well:</P>
<P><CODE><SPAN LANG="en-US">rule_name(): Type &larr; expression ;</SPAN></CODE></P>
<H4 CLASS="western">Example</H4>
<P LANG="en-US">The following input grammar:</P>
<P><CODE><SPAN LANG="en-US">main &larr; rule2 ;<BR>rule2(io) &larr; &hellip;
;</SPAN></CODE></P>
<P LANG="en-US">results in the following functions in the output
parser:</P>
<UL>
	<LI><P><CODE><SPAN LANG="en-US">yy_parse(io)</SPAN></CODE>&mdash;<SPAN LANG="en-US">it
	starts parsing input with main rule;</SPAN></P>
	<LI><P><CODE><SPAN LANG="en-US">rule2(io)</SPAN></CODE>&mdash;<SPAN LANG="en-US">it
	starts parsing input with rule2 rule.</SPAN></P>
</UL>
<DIV ID="sdfootnote1">
	<P CLASS="sdfootnote"><A CLASS="sdfootnotesym" NAME="sdfootnote1sym" HREF="#sdfootnote1anc">1</A><SPAN LANG="en-US">Its
	</SPAN><CODE><SPAN LANG="en-US">String#encoding</SPAN></CODE> <SPAN LANG="en-US">is
	set to &ldquo;</SPAN><CODE><SPAN LANG="en-US">UTF-8</SPAN></CODE>&rdquo;<SPAN LANG="en-US">.</SPAN></P>
</DIV>
<DIV ID="sdfootnote2">
	<P LANG="en-US" CLASS="sdfootnote"><A CLASS="sdfootnotesym" NAME="sdfootnote2sym" HREF="#sdfootnote2anc">2</A>Here
	&ldquo;..&rdquo; is Unicode character with code U+2025.</P>
</DIV>
<DIV ID="sdfootnote3">
	<P CLASS="sdfootnote"><A CLASS="sdfootnotesym" NAME="sdfootnote3sym" HREF="#sdfootnote3anc">3</A><SPAN LANG="en-US">Here
	</SPAN><CODE><SPAN LANG="en-US">expr</SPAN></CODE><SPAN LANG="en-US">,
	</SPAN><CODE><SPAN LANG="en-US">expr1</SPAN></CODE><SPAN LANG="en-US">,
	</SPAN><CODE><SPAN LANG="en-US">expr2</SPAN></CODE><SPAN LANG="en-US">,
	&hellip; are other valid expressions.</SPAN></P>
</DIV>
<DIV ID="sdfootnote4">
	<P CLASS="sdfootnote"><A CLASS="sdfootnotesym" NAME="sdfootnote4sym" HREF="#sdfootnote4anc">4</A><SPAN LANG="en-US">In
	all &ldquo;capture&rdquo; and &ldquo;append&rdquo; expressions you
	may put </SPAN><CODE><SPAN LANG="en-US">var</SPAN></CODE> <SPAN LANG="en-US">into
	parentheses. For example, &ldquo;</SPAN><CODE><SPAN LANG="en-US">expr:(var)</SPAN></CODE>&rdquo;
	<SPAN LANG="en-US">and &ldquo;</SPAN><CODE><SPAN LANG="en-US">&lt;expr&gt;:+(var)</SPAN></CODE>&rdquo;
	<SPAN LANG="en-US">are also valid expressions.</SPAN></P>
</DIV>
</BODY>
</HTML>