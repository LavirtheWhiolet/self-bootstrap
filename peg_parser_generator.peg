%%
#!/usr/bin/ruby
# encoding: UTF-8


class PEGParserGenerator
  
  def call(input)
    # Initialize.
    @next_unique_number = 0
    # Parse!
    p yy_parse(input)
  end
  
  private
  
  HashMap = Hash
  
%%

---- Syntax ----

# NOTE: Semantic value of all "expr..." rules is Code.

grammar <-
  ` ` val:expr $ ;

expr <- val:expr10 ;

expr10 <-
  (
    # Rules introduction.
    (
      r:rules `in` c:expr10 /
      c:expr30 `where` r:rules /
      r:rules { c = code("#{r.first_value.method_name}") }
    )
    { val = link(c, r) }
  ) /
  val:expr30 ;

expr20 <-
  # Ordered choice.
  {
    
    need_remember_position = false
  }
  val:expr30
  (
    `/` val2:expr30
    {
      val += code("")
    }
  )*
  ;

expr30 <-
  # Sequence.
  val:expr100 (val2:expr100 { val += code(" and ") + val2 })* ;

expr100 <-
  s:string  { val = code %(yy_string(#{s.force_encoding("UTF-8").dump})) } /
  n:nonterminal  { val = UnknownCode[n] } ;

# Semantic value is HashMap1 from rule's left part (nonterminal) to
# its right part (Definition).
rules <-
  { val = HashMap1.new }
  (
    r:rule
    {
      nonterminal, definition = *r
      raise %(rule "#{nonterminal}" is already defined) if val.has_key? nonterminal
      val[nonterminal] = definition
    }
  )+
  ;

# Semantic value is [nonterminal, Definition].
rule <-
  n:nonterminal `<-/=` c:expr `;`
  { val = [n, to_method_definition(c, new_unique_nonterminal_method_name)] } ;

---- Lexemes ----

# TODO: Space before every ";".

`<-/=` <- ("<-" / "=") ` `;
`;` <- ";" ` `;
`/` <- "/" ` `;

`where` <- "where" !nonterminal-middle ` `;
`in` <- "in" !nonterminal-middle ` `;
keyword <-
  `where` /
  `in` ;

# Semantic value is nonterminal's name.
nonterminal <-
  !keyword
  (
    val:< nonterminal-start (nonterminal-middle)* > ` ` /
    val:< "`" (!"`" char)* "`" > ` `
  ) ;

nonterminal-start <-
  "a"..."z" /
  "A"..."Z" /
  "-" /
  "_" ;

nonterminal-middle <-
  nonterminal-start /
  "0"..."9" ;

# Semantic value is the string's body.
string <-
  "'" val:< (!"'" char)* > "'" ` ` /
  '"' val:< (!'"' char)* > '"' ` ` /
  code:Unicode-code ` ` { val = "".force_encoding("UTF-8") << code } ;

# Semantic value is integer number.
Unicode-code <-
  "U+" code:< ("0"..."9" / "A"..."F")+ >
  { val = code.to_i(16) } ;

# Insignificant text.
` ` <-
  (white-space / comment)* ;

comment <-
  ("#" / "--") (!newline char)* newline ;

# White space as specified in "Unicode Standard Annex #44: Unicode Character
# Database" (http://www.unicode.org/reports/tr44, specifically
# http://www.unicode.org/Public/UNIDATA/PropList.txt).
white-space <-
  U+0009...U+000D /
  U+0020 /
  U+0085 /
  U+00A0 /
  U+1680 /
  U+180E /
  U+2000...U+200A /
  U+2028 /
  U+2029 /
  U+202F /
  U+205F /
  U+3000 ;

# Newline as specified in "Unicode Technical Report #13: Unicode Newline
# Guidelines" (http://unicode.org/unicode/standard/reports/tr13/tr13-5.html).
newline <-
  U+000D U+000A /
  U+000D /
  U+000A /
  U+0085 /
  U+000B /
  U+000C /
  U+2028 /
  U+2029 ;

%%
  
  # returns unique value on each call. The value starts with "yy_nonterm" and is
  # lowcase.
  def new_unique_nonterminal_method_name
    "yy_nonterm#{new_unique_number.to_s(36)}"
  end
  
  # returns unique number on each call.
  def new_unique_number
    result = @next_unique_number
    @next_unique_number += 1
    return result
  end
  
  # 
  # See source code.
  # 
  def link(code, nonterminal_to_definition)
    # Add all definitions to the code.
    nonterminal_to_definition.values.each do |definition|
      code += definition
    end
    # Replace all unknown codes with corresponding method calls (where
    # possible).
    nonterminal_to_definition.each do |nonterminal, definition|
      code = code.replace_unknown_code(nonterminal, definition.method_name)
    end
    #
    return code
  end
  
  def to_method_definition(code, method_name)
    Definition[
      method_name,
      code("def #{method_name} \n") +
        code("val = :yy_nil \n") +
        code + code(" and yy_to_pcv(val) \n") +
      code("end \n")
    ]
  end
  
  # 
  # The Code consists of 2 parts: the code as such (which can be got with #to_s)
  # and code of definitions (which can be got with #definitions_to_s).
  # 
  # Abstract.
  # 
  class Code
    
    # defines abstract method.
    def self.abstract(method)
      define_method(method) { |*args| raise %(method `#{method}' is abstract) }
    end
    
    abstract :to_s
    
    def definitions_to_s
      ""
    end
    
    # 
    # returns this Code with UnknownCode-s having specified
    # UnknownCode#nonterminal (+nonterminal+) replaced with +code+.
    # 
    def replace_unknown_code(nonterminal, code)
      return self
    end
    
    # Non-overridable.
    def + other
      CodeConcatenation.new([self, other])
    end
    
  end
  
  class CodeAsString < Code
    
    class << self
      
      alias [] new
      
    end
    
    def initialize(string)
      @string = string
    end
    
    def to_s
      @string
    end
    
    def inspect
      "#<CodeAsString: #{@string.inspect}>"
    end
    
  end
  
  # returns CodeAsString.
  def code(string)
    CodeAsString.new(string)
  end
  
  class CodeConcatenation < Code
    
    def initialize(parts)
      @parts = parts
    end
    
    def replace_unknown_code(nonterminal, code)
      CodeConcatenation.new(@parts.map { |part| part.replace_unknown_code(nonterminal, code) })
    end
    
    def to_s
      @parts.map { |part| part.to_s }.join
    end
    
    def definitions_to_s
      @parts.map { |part| part.definitions_to_s }.join
    end
    
    def + other
      # Optimization.
      CodeConcatenation.new([*@parts, other])
    end
    
    def inspect
      "#<CodeConcatenation: #{@parts.map { |p| p.inspect }.join(", ")}>"
    end
    
  end
  
  class UnknownCode < Code
    
    class << self
      
      alias [] new
      
    end
    
    def initialize(nonterminal)
      @nonterminal = nonterminal
    end
    
    # Nonterminal associated with this UnknownCode.
    attr_reader :nonterminal
    
    def replace_unknown_code(nonterminal, code)
      if self.nonterminal == nonterminal then code
      else self
      end
    end
    
    def to_s
      raise UnknownCodeEncountered, self
    end
    
    def inspect
      "#<UnknownCode: @nonterminal=#{@nonterminal.inspect}>"
    end
    
  end
  
  class UnknownCodeEncountered < Exception
    
    def initialize(code)
      super %(unknown code with nonterminal #{code.nonterminal} is encountered)
      @code = code
    end
    
    attr_reader :code
    
  end
  
  # A code which goes to "definitions" section.
  class Definition < Code
    
    class << self
      
      alias [] new
      
    end
    
    def initialize(method_name, code)
      # Fix common errors.
      code = CodeAsString[code] if code.is_a? String
      # 
      @code = code
      @method_name = method_name
    end
    
    def replace_unknown_code(nonterminal, code)
      Definition.new(@method_name, @code.replace_unknown_code(nonterminal, code))
    end
    
    def to_s
      ""
    end
    
    # Method name associated with this Definition.
    attr_reader :method_name
    
    def definitions_to_s
      @code.to_s + @code.definitions_to_s
    end
    
    def inspect
      "#<Definition: #{@code.inspect}>"
    end
    
  end
  
  class HashMap1 < HashMap
    
    def initialize(*args, &block)
      super(*args, &block)
      @first_value = nil
    end
    
    def []=(key, value)
      raise %(value can not be nil) if value.nil?
      @first_value ||= value
      super(key, value)
    end
    
    attr_reader :first_value
    
  end
  
end


if $0 == __FILE__
  File.open(ARGV[0]) do |io|
    PEGParserGenerator.new.call(io)
  end
end
