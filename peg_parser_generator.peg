%%
#!/usr/bin/ruby
# encoding: UTF-8


class PEGParserGenerator
  
  def call(input)
    puts yy_parse(input)
  end
  
  private
  
%%

grammar <-
  ` ` value:string ;

# Semantic value is the string's body.
string <-
  "'" value:< (!"'" char)* > "'" ` ` /
  '"' value:< (!'"' char)* > '"' ` ` /
  code:Unicode-code ` ` { value = "".force_encoding("UTF-8") << code } ;

# Semantic value is integer code.
Unicode-code <-
  "U+" code:< ("0"..."9" / "A"..."F")+ >
  { value = code.to_i(16) } ;

# Insignificant text.
` ` <-
  (white-space / comment)* ;

comment <-
  ("#" / "--") (!newline char)* newline ;

# White space as specified in "Unicode Standard Annex #44: Unicode Character
# Database" (http://www.unicode.org/reports/tr44, specifically
# http://www.unicode.org/Public/UNIDATA/PropList.txt).
white-space <-
  U+0009...U+000D /
  U+0020 /
  U+0085 /
  U+00A0 /
  U+1680 /
  U+180E /
  U+2000...U+200A /
  U+2028 /
  U+2029 /
  U+202F /
  U+205F /
  U+3000 ;

# Newline as specified in "Unicode Technical Report #13: Unicode Newline
# Guidelines" (http://unicode.org/unicode/standard/reports/tr13/tr13-5.html).
newline <-
  U+000D U+000A /
  U+000D /
  U+000A /
  U+0085 /
  U+000B /
  U+000C /
  U+2028 /
  U+2029 ;

%%
  
  # Abstract.
  class Code
    
    def self.abstract
      raise %(method is abstract)
    end
    
    def to_s
      abstract
    end
    
    def + other
      CodeConcatenation.new([self, other])
    end
    
  end
  
  class CodeAsString < Code
    
    def initialize(string)
      @string = string
    end
    
    def to_s
      @string
    end
    
  end
  
  def code(string)
    CodeAsString.new(string)
  end
  
  class CodeConcatenation < Code
    
    def initialize(parts)
      @parts = parts
    end
    
    def to_s
      @parts.map { |part| part.to_s }.join
    end
    
    def + other
      # Optimization.
      CodeConcatenation.new([*@parts, other])
    end
    
  end

end


if $0 == __FILE__
  File.open(ARGV[0]) do |io|
    PEGParserGenerator.new.call(io)
  end
end
