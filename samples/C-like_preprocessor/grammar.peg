{...
#!/usr/bin/ruby
# encoding: UTF-8
require 'stringio'


class Preprocessor

  def call(input, already_defined_macros = Hash.new)
    @last_newline_pos = 0
    @macros = already_defined_macros
    yy_parse(input)
  end
  
  private
  
}...

text =
  { val = "" }
  (text-element:e { val << e })* ;

# Semantic value is processed text element.
text-element: String =
  / macro-definition { val = "" }
  / macro-undefinition { val = "" }
  / macro-name:(macro_name) { val = expand(macro_name) }
  / string:(val)
  / comment:(val)
  / < newline >:val  # It is required to track last newline position.
  / < char >:val
  ;

{...
  
  def expand(macro_name)
    if @macros.has_key? macro_name then
      val = @macros[macro_name]
      val = Preprocessor.new.(StringIO.new(@macros[macro_name]), @macros.dup)
    else
      val = macro_name
    end
  end
  
}...

macro-definition =
  `#` "define" ` ` macro-name:(macro_name) ` ` macro-body:(macro_body) line-end
  { @macros[macro_name] = macro_body } ;

macro-undefinition =
  `#` "undef" ` ` macro-name:(macro_name) line-end
  { @macros.delete macro_name } ;

`#` =
  line-start "#" ` ` ;

` ` =
  " "* ;

macro-name: String =
  < macro-name-start macro-name-middle* >:val ;

macro-name-start =
  / "a"..."z"
  / "A"..."Z"
  / "_"
  ;

macro-name-middle =
  / macro-name-start
  / "0"..."9"
  ;

macro-body: String =
  { val = "" }
  (
    (
      / < string >:s
      / < comment >:s
      / "\" < newline >:s
      / < !newline char >:s
    )
    { val << s }
  )* ;

comment: String =
  / < "//" char*? line-end >:val
  / < "/*" char*? "*/" >:val
  ;

string: String =
  < '"' ("\" char / char)*? '"' >:val ;

# NOTE: It also sets @last_newline_pos in case of success.
newline =
  @:(x)
  (
    / U+000D U+000A
    / U+000D
    / U+000A
  )
  { @last_newline_pos = x } ;

line-start =
  ^ / &(at @last_newline_pos: newline) ;

line-end =
  newline / $ ;

{...

end


File.open(ARGV[0]) do |input|
  print Preprocessor.new.(input)
end

}...
